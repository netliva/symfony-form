<?phpnamespace Netliva\SymfonyFormBundle\Form\Types;use Netliva\SymfonyFormBundle\Form\DataTransformer\EntityToIdTransformer;use Symfony\Component\DependencyInjection\ContainerInterface;use Symfony\Component\Form\AbstractType;use Symfony\Component\Form\Extension\Core\Type\TextType;use Symfony\Component\Form\FormBuilderInterface;use Symfony\Component\Form\FormInterface;use Symfony\Component\Form\FormView;use Symfony\Component\OptionsResolver\OptionsResolver;class NetlivaAutocompleteType extends AbstractType{	private $container;	public function __construct(ContainerInterface $container)	{	    $this->container = $container;	}	public function configureOptions(OptionsResolver $resolver)	{	    $resolver->setDefaults(array(			'multiselect'       => false,			'multiselect_limit' => false,			'entity_alias'      => null,			'class'             => null,			'choice_label'      => null,			'compound'          => false,			'transformer'       => true		));	}	public function getParent()	{	    return TextType::class;	}	public function buildForm(FormBuilderInterface $builder, array $options)	{		$entities = $this->container->getParameter('netliva_form.autocomplete_entities');		$aliasInfo = $entities[$options['entity_alias']];		if ($options['transformer'] && count($aliasInfo) == 1)		{			$aliasInfo = current($aliasInfo);			$em = $this->container->get('doctrine')->getManager($aliasInfo['em']);			$builder->addModelTransformer(new EntityToIdTransformer($em, $aliasInfo));		}	    $builder->setAttribute('entity_alias', $options['entity_alias']);	}	public function buildView(FormView $view, FormInterface $form, array $options)	{	    $entities = $this->container->getParameter('netliva_form.autocomplete_entities');		$ea = $form->getConfig()->getAttribute('entity_alias');		$view->vars = array_merge($view->vars, [			'entity_alias'      => $ea,			'multiselect'       => $options['multiselect'],			'multiselect_limit' => $options['multiselect_limit'],			'entity_config'     => array_map(function($key, $val){					return ["conf_key"=>$key, "other_values" => $val["other_values"], "template" => $val["template"], "data" => key_exists("data", $val) ? $val["data"] : null];				}, array_keys($entities[$ea]), $entities[$ea]),	  	]);	}	public function getBlockPrefix()	{	    return 'netliva_autocomplete';	}}